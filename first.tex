\section{Первая программа на С++}
\subsection{Минимальная программа}

Пример минимальной программы:

\lstset{style=CPlusPlus}
\begin{lstlisting}
int main()
{
    // nothing interesting in this program...

    /*
        Seriously, we doesn't have even message about Hello World!
        I hope that we fix this in another section...
    */
    return 0;
}
\end{lstlisting}

В данном примере представлена функций \lstinline|main|, которая является точкой входа программы. Может быть сколько угодно функций в программе, но функция \lstinline|main| обязана присутствовать среди них, причем в единственном экземпляре! Исполнение всей программы начинается именно с этой функции. \lstinline|int| перед названием функции говорит о том, что данная функция должна вернуть целочисленное значение. \lstinline|main| возвращает результат выполнения программы~---~\lstinline|return 0| означает, что программа выполнилась без ошибки и корректно завершила свою работу. В противном случае необходимо вернуть ненулевое значение.

Обратите внимание, что при помощи $//$ можно комментировать программу~---~то есть на данной строке ничего выполняться не будет. Комментарий можно растянуть на несколько линий, обрамив его между $/*$ и $*/$. Примеры комментариев представлены в коде сверху.

\subsection{Программа <<Hello, world!>>, запись в консоль данных}

Усложним программу, добавив вывод строки <<Hello, world!>> на экран консольного приложения:

\begin{lstlisting}
#include <iostream>

int main()
{
    std::cout << "Hello, world!" << std::endl;
    return 0;
}
\end{lstlisting}

В данной программе, по отношению к предыдущей, добавились две строчки:

\begin{itemize}
    \item \lstinline!#include <iostream>!
    \item \lstinline|std::cout << "Hello, world!" << std::endl;|
\end{itemize}

\lstinline!#include <iostream>! является директивой (командой) препроцессора. Данные строки обрабатываются им \emph{до} компиляции программы. Данная команда позволяет препроцессору включить в программу содержимое заголовочного файла \lstinline!iostream!, который отвечает за работу потоков ввода\textbackslash вывода. Данный файл необходимо включать в любую программу, где ожидается работа с консолью~---~когда данные считываются с консоли и когда необходимо передать какие-нибудь данные консоли.

Вся строка \lstinline|std::cout << "Hello, world!" << std::endl;| является оператором. Каждый оператор в языке оканчивается символом $;$.

Ввод\textbackslash вывод в С++ осуществляется с помощью символьных потоков:
\begin{itemize}
    \item \lstinline!std::cin!~---~стандартный входной поток;
    \item \lstinline!std::cout!~---~стандартный выходной поток;
    \item \lstinline!std::cerr!~---~стандартный поток ошибок.
\end{itemize}

Обратите внимание, что перед \lstinline|cin|, \lstinline|cout| и \lstinline|cerr| помещено \texttt{std::}. Это означает, что данные потоки принадлежат \textit{пространству имен} (\textit{namespace}) \texttt{std}. Пространства имен нужны для удобной организации объектов и операторов по смыслу.

Операция \lstinline|<<| называется \emph{операцией передачи в поток}. При выполнении этой операции то, что стоит справа, передается в поток, который стоит слева. Обратите внимание на направленность данной операции~---~данные передаются в поток справа налево! \lstinline|std::endl| является функцией, которая возвращает символ перевода на новую строчку.

Для того, чтобы постоянно не использовать в коде определенное пространство имен, можно воспользоваться двумя методами:
\begin{enumerate}
    \item Использовать для текущей файла всё пространство имен целиком:
    \begin{lstlisting}
#include <iostream>
using namespace std;

int main()
{
    cout << "Hello, world!" << endl;
    return 0;
}
    \end{lstlisting}

    \item Вынести отдельные объекты и операции:
    \begin{lstlisting}
#include <iostream>
using std::cout;
using std::endl;

int main()
{
    cout << "Hello, world!" << endl;
    return 0;
}
    \end{lstlisting}
\end{enumerate}

Рекомендуется использовать второй метод, если количество объявлений не очень большое, в противном случае не возбраняется подключать все пространство имен.

Записывать в стандартный выходной поток можно не только строки, но и данные других типов:

\begin{lstlisting}
#include <iostream>
int main()
{
    int a = 5;
    int b = 7;
    std::cout << a + b << std::endl;
}
\end{lstlisting}

\subsection{Чтение данных с консоли}

С помощью потока \lstinline|std::cin| можно считывать данные, которые вводятся с консоли:
\begin{lstlisting}
#include <iostream>
int main()
{
    int a = 0;
    int b = 0;
    int c = 0;

    std::cout << "Enter a:" << std::endl;
    std::cin >> a;

    std::cout << "Enter b:" << std::endl;
    std::cin >> b;

    std::cout << "a + b = " << a + b << std::endl;
}
\end{lstlisting}

Операция $<<$ называется \textit{операцией извлечения из потока}. При выполнении данной операции данные из стандартного входного потока слева будут переданы переменной, которая находится справа.

\section{Справочный материал по С++}

\subsection{Переменные (объявление, типы, операции с переменными)}

\subsubsection{Объявление переменных}
Синтаксис объявления переменных:

\lstinline|<Modification> <Type> variableName = variableValue;|

\lstinline|Type| --- тип переменной, \lstinline|Modification| --- изменение (модификация), накладываемое на переменную, \lstinline|variableName| --- имя переменной, \lstinline|variableValue| --- значение переменной.

После объявления переменной имеет смысл назначить ей какое-либо допустимое значение. Даже если переменная будет изменяться в дальнейшем коде программы, правилом хорошего тона является выставления значения по умолчанию, в противном случае при выполнении программы в этих переменных может оказаться <<мусор>> (случайные значения).

Инициализацию переменной можно двумя способами:
\begin{itemize}
    \item Через оператор \lstinline{=} :

        \lstinline|int a = 5;|
    \item Через оператор \lstinline{()} --- инициализация переменной с помощью конструктора:

         \lstinline|int a(5);|
\end{itemize}

На одной строке можно объявлять несколько переменных одного типа:
\begin{lstlisting}
int p = 2,k = 3;
double s,m; // bad thing, because there is no initialization!
\end{lstlisting}

\subsubsection{Типы переменных}
Стандартные типы:
\begin{enumerate}
    \item \lstinline|bool| --- логический тип;
    \item \lstinline|char| --- целочисленный тип, используется для представления символов ('a', 'z', '.', \ldots);
    \item \lstinline|int| --- целочисленный тип, используется для хранения \textbf{целых} чисел;
    \item \lstinline|float| --- вещественный тип, используется для хранения \textbf{дробных} чисел;
    \item \lstinline|double| --- вещественный тип, используется для хранения \textbf{дробных} чисел, обладает большей точностью, чем тип \lstinline|float|.
\end{enumerate}

Возможные модификаторы:
\begin{enumerate}
    \item \lstinline|const| --- запрет менять значение переменной в ходе программы. Если попытаться поменять где-нибудь константу, то компилятор сообщит о ошибке:
    \begin{lstlisting}
const double pi = 3.1415;
pi = 3.0; // This is wrong!!!
    \end{lstlisting}
    \item \lstinline|unsigned| --- переменная будет принимать только положительные значения;
    \item \lstinline|short|--- укорачивает диапазон переменных;
    \item \lstinline|long| --- увеличивает диапазон переменных.
\end{enumerate}

Размерности переменных:
\begin{table}[ht]
    \centering
    \begin{tabular}{|>{\centering\arraybackslash}m{4cm}|>{\centering\arraybackslash}m{2cm}|>{\centering\arraybackslash}m{10cm}|}
        \hline
        \textit{Тип} & \textit{Размер в байтах} & \textit{Диапазон} \\
        \hline
        \lstinline|bool| & 1 & true/false \\
        \hline
        \lstinline|char| & 1 & \numrange{-128}{127} \\
        \hline
        \lstinline|unsigned char| & 1 & \numrange{0}{255} \\
        \hline
        \lstinline|short int| & 2 & \numrange{-32 768}{32 767} \\
        \hline
        \lstinline|unsigned short int| & 2 & \numrange{0}{65 535} \\
        \hline
        \lstinline|int| & 4 & \numrange{-2 147 483 648}{2 147 483 647} \\
        \hline
        \lstinline|unsigned int| & 4 & \numrange{0}{4 294 967 295} \\
        \hline
        \lstinline|long int| & 4 & \numrange{-2 147 483 648}{2 147 483 647} \\
        \hline
        \lstinline|unsigned long int| & 4 & \numrange{0}{4 294 967 295} \\
        \hline
        \lstinline|long long| & 8 & \num{-9 223 372 036 854 775 808} \ldots \newline \ldots \num{9 223 372 036 854 775 807} \\
        \hline
        \lstinline|unsigned long long| & 8 & \numrange{0}{18 446 744 073 709 551 615} \\
        \hline
        \lstinline|float| & 4 & $\pm 3.4\cdot 10^{\pm 38}$ (7 цифр) \\
        \hline
        \lstinline|double| & 8 & $\pm 1.7\cdot 10^{\pm 308}$ (15 цифр) \\
        \hline
    \end{tabular}
\end{table}



\subsubsection{Операции с переменными}
Стандартные арифметические операции над переменными:
\begin{enumerate}
    \item Операция присваивания (\lstinline{=}). Значение выражения присваивается переменной:
    \begin{lstlisting}
int a = 5;
int b = 42; // a = 5, b = 42
a = b; // a = 42, b = 42
    \end{lstlisting}
    \item Операция сложения (\lstinline{+}), вычитания (\lstinline{-}), умножения (\lstinline{*}), целочисленное деление (\lstinline{/}), взятие остатка по модулю (\lstinline{%}):
    \begin{lstlisting}
int a = 5;
int b = 3;

int l = 5 + 3 - 1; // l = 7
int c = a + b; // c = 8
int d = a - b; // d = 2
int k = a * b; // k = 15
int div = a / b; // div = 1
int mod = a % b; // mod = 2
    \end{lstlisting}

    Первоначально обрабатываются операции умножения, деления и взятия остатка по модулю. Если операций несколько, то выполняются слева направо. После этих операций по такому же принципу обрабатываются и операции сложения и вычитания.

    \item Операция \lstinline{()}. Выражения в скобках оцениваются в первую очередь. В случае вложенных скобок вычисляется значение во внутренних скобках. Если есть одинаковые скобки <<одного уровня>> --- они вычисляются слева направо.
\end{enumerate}

Существуют короткие формы записей арифметических операций:
\begin{lstlisting}
a += b --> a = a + b
a -= b --> a = a - b
a *= b --> a = a * b
a /= b --> a = a / b
a %= b --> a = a % b
\end{lstlisting}

В \texttt{С++} существуют операции инкремента (\lstinline{++}) и декремента (\lstinline{--}). Данные операции увеличивают или уменьшают значение переменной на 1. Различают префиксную форму (\lstinline{++a}\textbackslash \lstinline{--b}) и суффиксную (постфиксную) форму (\lstinline{a++}\textbackslash \lstinline{b--}). Различие между формами в том, что при использовании префиксной формы значение переменной изменяется сразу же, как программа выполняет данную операцию; в суффиксной --- программа сперва использует старое значение, а потом изменяет его.

Операции сравнения над переменными:
\begin{enumerate}
    \item Операция равенства (\lstinline{==}). Принимает значение \textbf{true}, если оба выражения равны, в противном случае --- \textbf{false}. \textit{Не следует путать с присваиванием значения переменной!!!}

    \begin{lstlisting}
bool result = 4 % 2 == 0; // true

int a = 5;
int b = 2;
bool newResult = a == b; // false
    \end{lstlisting}

    \item Операция неравенства (\lstinline{!=}). Принимает значение \textbf{true}, если оба выражения различны, в противном случае --- \textbf{false};
    \item Операции отношения (\lstinline{>}, \lstinline{<}, \lstinline{>=}, \lstinline{<=}). Возвращают значение типа \textit{bool} в зависимости от своей функции:

    \begin{lstlisting}
bool a = 5 > 3; // true
bool b = 4 < 2; // false
bool c = 6 <= 6; // true
bool d = 5 >= 2; // true
    \end{lstlisting}
\end{enumerate}

Логические операции:

\begin{enumerate}
    \item Логическое отрицание (\lstinline{!}) --- Инвертирует логическое значение;
    \item Логическое умножение, И (\lstinline{&&}). Если первое выражение равно \textit{false}, то тогда вычисление второго выражения не производится;
    \item Логическое сложение, ИЛИ (\lstinline{||}). Первое выражение вычисляется всегда, второе вычисляется в том случае, если первое выражение принимает значение \textit{fasle}.
\end{enumerate}

Прочие операции:
\begin{itemize}
    \item \lstinline{?:} --- тернарный оператор, подробнее в~\ref{subsubsec:ternaryOperator};
    \item \lstinline{[]} --- взятие элемента массива по индексу, подробнее в~\ref{subsec:Arrays}.
\end{itemize}

\subsubsection{Приоритеты и ассоциативность операций}

\begin{table}[ht]
    \centering
    \begin{tabular}{|>{\centering\arraybackslash}m{3cm}|>{\centering\arraybackslash}m{5cm}|>{\centering\arraybackslash}m{5cm}|}
        \hline
        \textit{Операции} & \textit{Ассоциативность} & \textit{Тип} \\
        \hline
        \lstinline!()! \lstinline![]! & слева направо & наивысший приоритет \\
        \hline
        \lstinline!++! \lstinline!--! & слева направо & унарные (постфиксные) \\
        \hline
        \lstinline!++! \lstinline!--! \lstinline|!| & справа налево & унарные (префиксные) \\
        \hline
        \lstinline!*! \lstinline!/! \lstinline!%! & слева направо & мультипликативные \\
        \hline
        \lstinline!+! \lstinline!-! & слева направо & аддитивные \\
        \hline
        \lstinline!<<! \lstinline!>>! & слева направо & передача\textbackslash извлечение из потока \\
        \hline
        \lstinline!<! \lstinline!<=! \lstinline!>! \lstinline!>=! & слева направо & отношения \\
        \hline
        \lstinline!==! \lstinline|!=| & слева направо & равенства \\
        \hline
        \lstinline!&&! & слева направо & логическое И \\
        \hline
        \lstinline!||! & слева направо & логическое ИЛИ \\
        \hline
        \lstinline!?:! & справа налево & условная \\
        \hline
        \lstinline!=! \lstinline!+=! \lstinline!-=! \lstinline!*=! \lstinline!/=! \lstinline!%=! & справа налево & присваивания \\
        \hline
        \lstinline!,! & слева направо & запятая \\
        \hline
    \end{tabular}
\end{table}

\subsection{Условный оператор \texttt{if}, тернарный оператор, оператор \texttt{switch}}
\subsubsection{Условный оператор \texttt{if}}
Общая структура условного оператора:
\begin{lstlisting}
if (expression_1)
    statement_1
[else
    statement_2]
\end{lstlisting}

\lstinline|expression| --- логическое выражение; \lstinline|statement\_X| --- выполняемая операция.

Начало условия задается ключевым словом \lstinline|if|, после которого в круглых скобках идет логическое выражение типа \lstinline|bool|. Наличие круглых скобок вне выражения обязательно, в противном случае компилятор выкинет ошибку. После выражения идут операции, которые следует выполнять в том случае, если выражение в круглых скобках истинно. Если операций несколько, то необходимо поставить фигурные скобки, в противном случае ими можно обойтись.

Пример условия:

\begin{lstlisting}
int a = 13;
if (a < 16)
    a = a + 2;

// a = 15

int count = 2;
if (count > 3)
{
    count++;
    age += 5;
}

// count = 2, age = 15
\end{lstlisting}

Если необходимо выполнить набор действий в том случае, когда выражение ложно, то необходимо поставить ключевое слово \lstinline|else| и перечислить набор операций (если операция одна, то фигурные скобки можно опустить, в противном случае они обязательны). Если условие не предполагает действий в том случае, если выражение в скобках ложно, то нет необходимости ставить \lstinline|else|.

Пример:
\begin{lstlisting}
int a = 5;
int b = 0;

if (a % 2 == 0)
    b++;
else
{
    a--;
    b--;
}

// b = -1
\end{lstlisting}

Допускается использования нескольких блоков \lstinline|if| \ldots \lstinline|else|:

\begin{lstlisting}
int age = 15;

if (age <= 3)
    ...
else if (age > 3 && age <= 7)
    ...
else if (age > 7 && age <= 18)
    ...
else
    ...
\end{lstlisting}

\subsubsection{Тернарный оператор}
\label{subsubsec:ternaryOperator}
Тернарный оператор возвращает одно из двух выражений в зависимости от результата логического выражения.

Структура тернарного оператора:

\begin{lstlisting}
expression ? statement_1 : statement_2;
\end{lstlisting}

Оператор сначала вычисляет выражение \lstinline{expression}.
Если это выражение принимает значение \lstinline|true|,
то результатом выполнения всего оператора будет \lstinline|statement_1|,
а в противном случае~---~\lstinline|statement_2|.

Пример:
\begin{lstlisting}
int a = 3, b = 5;
int min = a < b ? a : b;
// a = 3
\end{lstlisting}

\subsubsection{Оператор \texttt{switch}}
Структура оператора \lstinline|switch|:
\begin{lstlisting}
switch ( expression )
{
    case constant-expression : statement
    [default   : statement]
}
\end{lstlisting}

\lstinline|expression| --- выражение, которое можно привести к целочисленному типу; \lstinline|constant-expression| --- константное значение, если выражение будет иметь данное значение, то произойдет обработка блока \lstinline|statement|. Если ни один из \lstinline|case|'ов не сработал, то вычисляется \lstinline|statement| в блоке \lstinline|default|, однако данный блок не обязателен к указанию и может быть опущен --- в таком случаю программа перейдет к выполнению следующих инструкций после оператора \lstinline|switch|.

Пример использования:
\begin{lstlisting}
int month = 4;
switch (month)
{
    case 1:
        ...
        break;
    case 2:
        ...
        break;
    ...
    case 4:
        ...
        break;
    ...
    case 12:
        ...
        break;
    default:
        ...
}
\end{lstlisting}

В данном примере будут выполняться инструкции, которые идут в блоке \lstinline|case 4:|. Обратите внимание, что после окончания инструкций в блоке стоит оператор \lstinline|break|~---~он необходим для прекращения работы оператора \lstinline|switch| после выполнения команд в блоке, в противном случае оператор \lstinline|switch| будет продолжать свою работу!

Существует возможность указания нескольких \lstinline|case|'ов для одного и того же блока команд:

\begin{lstlisting}
char answer = 'y';
switch (answer)
{
    case 'y':
    case 'Y':
        ...
        break;
    case 'n':
    case 'N':
        ...
        break;
}
\end{lstlisting}

\subsection{Циклы \texttt{while}, \texttt{do-while}, \texttt{for}}
\subsubsection{Цикл с предусловием (\texttt{while})}
Структура цикла \lstinline|while|:
\begin{lstlisting}
while (expression)
    statement
\end{lstlisting}

\lstinline|expression| --- выражение типа \lstinline|bool|, задает условие выхода из цикла; \lstinline|statement|~---~набор операций, которые будут выполняться в цикле (если операций больше одной, то нужно заключить их в фигурные скобки, в противном случае делать данное действие необязательно). Цикл \lstinline|while| будет выполняться до тех пор, пока \lstinline|expression| будет равно \lstinline|true|. Программа может не войти в тело цикла (то есть выполнить операции в нем), если изначально \lstinline|expression| будет равен \lstinline|false|.

Пример:

\begin{lstlisting}
int a = 0;
int b = 0;
while (a < 10)
{
    b *= a*a;
    a++;
}
\end{lstlisting}

Цикл \lstinline|while| можно досрочно завершить при помощи оператора \lstinline|break| (управление программы перейдет к следующей инструкции):

\begin{lstlisting}

char answer = 'v';

while (a != 'y')
{
    ...

    if (answer == 'q')
        break;

    ...
}

\end{lstlisting}

В данном примере выход из цикла произойдет в двух случаях: пока переменная \textit{answer} не примет значение \textit{y}, либо значение \textit{q}. Во втором случае все операции после данного условия не будут выполнены и произойдет выход из цикла.

Если использовать оператор \lstinline|continue| в цикле, то все операции выполняться также не будут, однако цикл не будет завершен и его выполнение будет продолжено с самой первой операции в цикле.

\subsubsection{Цикл с постусловием (\texttt{do-while})}
Структура цикла \lstinline|do-while|:
\begin{lstlisting}
do
    statement
while (expression);
\end{lstlisting}

\lstinline|expression| --- выражение типа \lstinline|bool|, задает условие выхода из цикла; \lstinline|statement|~---~набор операций, которые будут выполняться в цикле (если операций больше одной, то нужно заключить их в фигурные скобки, в противном случае делать данное действие необязательно). Цикл \lstinline|do-while| будет выполняться до тех пор, пока выражение \lstinline|expression| будет равно \lstinline|true|. В данном цикле блок \lstinline|statement| будет выполняться в первую очередь, условие выхода из цикла будет проверяться после выполнения операций. Операторы \lstinline|break| и \lstinline|continue| имеют такой же эффект, что и в цикле \lstinline|while|.

Пример:
\begin{lstlisting}
int a = 0;
do
{
    a++;
}
while (a < 10);
\end{lstlisting}

\subsubsection{Цикл со счетчиком (\texttt{for})}
Конструкция цикла \lstinline|for|:
\begin{lstlisting}
for (init-expression ; cond-expression ; loop-expression)
    statement
\end{lstlisting}

Обозначения:
\begin{itemize}
    \item \lstinline|init-expression| --- набор операций, которые выполняются один раз \textbf{до} начала цикла, чаще всего используется для инициализации переменных, которые будут использоваться в цикле для подсчета итераций;
    \item \lstinline|cond-expression| --- выражение типа \lstinline|bool|, которое задает условие выхода из цикла --- проверяется перед каждой итерацией цикла (в том числе и перед самой первой), если \textit{cond-expression} равное \lstinline|false|, то цикл завершается;
    \item \lstinline|loop-expression| --- набор операций, который выполняется после итерации цикла, обычно используется для изменения переменных, который подсчитывают количество итераций;
    \item \lstinline|statement| --- набор операций, которые будут производится в каждой итерации цикла (если операций больше одной, то нужно заключить их в фигурные скобки, в противном случае делать данное действие необязательно).
\end{itemize}

Пример:

\begin{lstlisting}
int sum = 0;
const int lim = 10;

for (int i = 0; i < lim; ++i)
    sum += i;
\end{lstlisting}

В блоках \lstinline|init-expression| и \lstinline|loop-expression| может быть несколько выражений, разделенных запятой:
\begin{lstlisting}
int sum = 0;

for (int i = 0, j = 0; i + j < lim; ++i, ++j)
    sum += i + j;
\end{lstlisting}

В блоке \lstinline|loop-expression| переменные, ответственные за количество
итераций, могут изменяться по-разному:
\begin{lstlisting}
for (int i = 10; i > 0; --i)
{
    ...
}

for (int k = 0; k > 200; k += 2)
{
    ...
}
\end{lstlisting}

Операторы \lstinline|break| и \lstinline|continue| имеют такой же эффект, что и в циклах \lstinline|while| и \lstinline|do-while|.

\subsection{Массивы}
\label{subsec:Arrays}
\subsubsection{Одномерные массивы}
Общая структура:

\lstinline|Type arrayName[arraySize];|

\lstinline|Type| --- тип элементов массива
(массив может состоять из целых чисел, дробных, символов, \ldots);
\lstinline|arrayName|~---~название массива; \lstinline|arraySize|~---~размер
массива. Индексы, по которым можно обращаться к элементам массива,
лежат в диапазоне~$\left[ 0 \ldots \text{arraySize} - 1 \right]$.

Обращение к элементу одномерного массива по индексу --- \texttt{arrayName[index]}.

Инициализация одномерного массива:
\begin{itemize}
    \item Использовать инициализатор \{\} при объявлении массива:

    \lstinline|int costs[4] = {100, 200, 300, 400};|

    В таком случае можно не указывать размер массива:

    \lstinline|int costs[] = {2, 4, 6};|

    \item Инициализировать массив при помощи циклов:
    \begin{lstlisting}
const int arraySize = 5;
int myArray[arraySize];

for (int i = 0; i < arraySize; ++i)
    myArray[i] = ...;
    \end{lstlisting}
\end{itemize}

Пример инициализированного массива:

\begin{table}[h]
    \begin{tabular}{|c|c|c|c|c|}
      \hline
      Индекс массива & 0 & 1 & 2 & 3 \\
      \hline
      Значение массива & 34 & -4 & 11 & 64 \\
      \hline
    \end{tabular}
\end{table}

Рекомендуется при работе с одномерными массивами инициализировать их, т.к. в противном случае в элементах массивов будет записан <<мусор>>!

\subsubsection{Двумерные массивы}
Общая структура:

\lstinline|Type arrayName[arraySizeRow][arraySizeColumn];|

\lstinline|Type| --- тип массива (массив может состоять из целых чисел, дробных, символов, \ldots); \lstinline|arrayName|~---~название массива; \lstinline|arraySizeRow|~---~количество одномерных массивов, \lstinline|arraySizeColumn|~---~размер каждого одномерного массива. Количество одномерных массивов лежит в диапазоне $\left[ 0 \ldots \text{arraySizeRow} - 1 \right]$, размерность одномерных массивов~---~$\left[ 0 \ldots \text{arraySizeColumn} - 1 \right]$. Обращение к элементу двумерного массива по индексам --- \texttt{arrayName[\textit{indexRow}][\textit{indexColumn}]}.

Инициализация двумерного массива:
\begin{itemize}
    \item Использовать инициализатор \{\} при объявлении массива:
    \begin{lstlisting}
int example[][5] =
{
    {100, 200, 300, 400},
    {200, 600, 1000, 1400},
    {1000, 800, 600, 400}
}
    \end{lstlisting}

    Обратите внимание, что указывается размерность одномерных массивов, но не количество этих массивов!

    \item Инициализировать массив при помощи циклов:
    \begin{lstlisting}
const int rowSize = 3;
const int columnSize = 5;
int myArray[rowSize][columnSize];

for (int i = 0; i < rowSize; ++i)
    for (int j = 0; j < columnSize; ++j)
        myArray[i][j] = ...;
    \end{lstlisting}
\end{itemize}

Пример инициализированного массива:
\begin{table}[h]
    \begin{tabular}{|c|c|c|c|c|}
        \hline
          & 0 & 1 & 2 & 3 \\
        \hline
        0 & 24 & 25 & 23 & 22 \\
        \hline
        1 & 1 & 2 & 3 & 4 \\
        \hline
        2 & 3 & 5 & 7 & 11 \\
        \hline
        3 & 10 & 15 & 20 & 25 \\
        \hline
        4 & 11 & 22 & 33 & 44 \\
        \hline
        5 & 0 & 2 & 4 & 6 \\
        \hline
    \end{tabular}
\end{table}

\subsection{Строки}
\subsubsection{Инициализация строк}
Для включения строк \texttt{C++} необходимо подключить заголовочный файл \lstinline|<string>|. Сам класс находится в пространстве имен \textbf{std}. Объект \lstinline|string| можно инициализировать:

\begin{enumerate}
    \item С помощью конструктора:
    \begin{lstlisting}
std::string text("Hello");
std::string anotherText(3, 'p'); // "ppp"
std::string emptyString;
    \end{lstlisting}

    В последнем случае \lstinline|std::string emptyString| вызывается конструктор по умолчанию, который создает пустую строку
    \item При помощи оператора \lstinline{=}, который вызывает конструктор:
    \begin{lstlisting}
std::string month = "August";
std::string emptyString = "";
    \end{lstlisting}
\end{enumerate}

Числа нельзя присваивать напрямую строке:
\begin{lstlisting}
std::string error = 'c'; // ERROR
std::string anotherError(8); // ERROR
\end{lstlisting}

Оператор \lstinline|>>| потока \lstinline|std::cin| может также работать со строками:
\begin{lstlisting}
std::string userAnswer;
std::cin >> userAnswer;
\end{lstlisting}

\subsubsection{Взятие символа строки (\texttt{[], at()}), размер строки (\texttt{length(), empty()})}
После инициализации строки можно обращаться к отдельным символам строки:
\begin{enumerate}
    \item Через оператор \lstinline|[]|:
    \begin{lstlisting}
std::string student = "Vasya";
std::cout << student[0]; // 'V'
std::cout << student[4]; // 'a'

student[2] = 'a';
std::cout << student; // "Vaaya"
    \end{lstlisting}
    \item Через метод \lstinline|at(int index)| класса \lstinline|string|:
    \begin{lstlisting}
std::string student = "Vasya";
std::cout << student.at(0); // 'V'
std::cout << student.at(3); // 'y'

student.at(0) = 'M';
std::cout << student; // "Masya"
    \end{lstlisting}
\end{enumerate}

Индексы, по которым можно обращаться к элементам строки,
лежат в диапазоне~$\left[ 0 \ldots \text{stringLength} - 1 \right]$.

Размер строки можно узнать с помощью метода \lstinline|length()|:
\begin{lstlisting}
std::string myString = "abcd";
std::cout << myString.length(); // 4
\end{lstlisting}

Для того, чтобы узнать, является ли строка пустой, можно вызывать метод \lstinline|empty()|:
\begin{lstlisting}
std::string nonEmptyString("qew12314");
std::string emptyString;

std::cout << nonEmptyString.empty() << std::endl; // 0
std::cout << emptyString.empty() << std::endl; // 1
\end{lstlisting}

\subsubsection{Присваивание (\texttt{assign()}) и конкатенация строк(\texttt{append()})}

Возможные варианты присваивания:
\begin{lstlisting}
std::string str1("test");
std::string str2,str3,str4;

str2 = str1; // str2 = "test";
str3.assign(str1); // str3 = "test";
\end{lstlisting}

Метод \lstinline|assign| можно использовать, когда необходимо присвоить \texttt{подстроку}. В таком случае метод принимает дополнительные параметры:

\lstinline|assign(source, startIndex, length)|

\textit{source}~---~строка типа \lstinline|string|, из которой будет браться подстрока, \lstinline|startIndex|~---~начальный индекс, с которого будет начинаться копирование, \lstinline|length|~---~количество символов, которые будут скопированы.
Необходимо, чтобы выполнялось условие~$length \leqslant source.length() - startIndex$.

Пример:
\begin{lstlisting}
std::string str1 = "abcd";
std::string str2;
str2.assign(str1, 2, 2);
std::cout << str2; // str2 = "cd";
\end{lstlisting}

Возможные варианты конкатенации:
\begin{lstlisting}
std::string str1("abcd");
std::string str2;

str2 += str1; // str2 = "abcd";
std::string str3(str1 + str2); // str5 = "abcdabcd"

std::string str4 = "zyx";
str4.append(str1); // str4 = "zyxabcd";
\end{lstlisting}

Метод \lstinline|append| можно использовать, когда необходима конкатенация \texttt{подстроки}. В таком случае метод принимает дополнительные параметры:

\lstinline|append(source, startIndex, length)|


\lstinline|source|~---~строка типа \lstinline|string|, из которой будет браться подстрока, \lstinline|startIndex|~---~начальный индекс, с которого будет начинаться копирование, \lstinline|length|~---~количество символов, которые будут скопированы.
Необходимо, чтобы выполнялось условие~$length \leqslant source.length() - startIndex$.

Пример:
\begin{lstlisting}
std::string str1 = "abcdfg";
std::string str2 = "111";
str2.append(str1, 1, 2);

std::cout << str2; // str2 = "111bc"
\end{lstlisting}

\subsubsection{Сравнение строк (\texttt{compare()})}
Строки сравниваются лексикографически. Сравнение происходит по первому несовпадающему символу, в противном случае сравниваются длины строк.
Строки можно сравнивать с помощью операторов \lstinline|==|, \lstinline|>|, \lstinline|<|:
\begin{lstlisting}
std::string str1("abcd");
std::string str2("Hello");
std::string str3(str2);
std::string str4("zxc");
std::string str5("zxcd");

std::cout << (str1 == str2) << endl; // false (0)
std::cout << (str2 == str3) << endl; // true (1)
std::cout << (str1 < str4) << endl; // true (1)
std::cout << (str1 > str2) << endl; // true (1)
std::cout << (str4 > str5) << endl; // false (0)
\end{lstlisting}

Сравнивать строки между собой можно с помощью метода \lstinline|compare()|. Функция возвращает 0, если строки одинаковы; значение меньше 0, если строка лексикографически меньше или все сопоставимые символы одинаковы, но строка меньше; значение больше 0, если строка лексикографически больше или все сопоставимые символы одинаковы, но строка больше.

Пример:

\begin{lstlisting}
std::string str1("abcd");
std::string str2("Hello");
std::string str3("zxc");
std::string str4("abcdfff");

std::cout << str1.compare(str1) << endl; // 0
std::cout << str1.compare(str2) << endl; // 1
std::cout << str1.compare(str3) << endl; // -1
std::cout << str1.compare(str4) << endl; // -1
\end{lstlisting}

Метод \lstinline|compare()| может сравнивать подстроку вызываемой строки с другой строкой:
\begin{lstlisting}
compare(startIndex, length, anotherString)
\end{lstlisting}

\lstinline|startIndex|~---~начальный индекс, с которого будет начинаться копирование, \lstinline|length|~---~количество символов, которые будут скопированы, \lstinline|anotherString|~---~строка, с которой будет сравниваться подстрока. Необходимо подбирать \lstinline|startIndex| и \lstinline|length| так, чтобы подстрока была корректной.

Пример:

\begin{lstlisting}
std::string str1("abcdefgh");
std::string str2("abcd");

std::cout << str1.compare(0, 4, str2) << endl; // 0
std::cout << str2.compare(3, 1, str1) << endl; // 1
\end{lstlisting}

Метод \lstinline|compare| может сравнивать подстроку вызываемой строки с подстрокой другой строки
\begin{lstlisting}
compare(startIndex, length, anotherString, anotherStartIndex, anotherLength)
\end{lstlisting}

\lstinline|startIndex|~---~начальный индекс, с которого будет начинаться копирование, \lstinline|length|~---~количество символов, которые будут скопированы, \lstinline|anotherString|~---~строка, с которой будет сравниваться подстрока, \lstinline|anotherStartIndex| и \lstinline|anotherLength| аналогичны по своим функциям с \lstinline|startIndex| и \lstinline|length|.

\subsubsection{Подстрока (\texttt{substr})}
С помощью метода \lstinline{substr} можно брать подстроки оригинальной строки:

\lstinline|substr(startIndex, length)|

Пример использования:
\begin{lstlisting}
std::string first("abcdefg");
std::string subFirst = first.substr(3, 4); // "defg"
\end{lstlisting}

\subsubsection{Поиск подстрок и символов (\texttt{find, rfind, find\_first\_of, \\find\_last\_of, find\_first\_not\_of, find\_last\_not\_of})}

Для поиска подстрок необходимо использовать методы \lstinline|find()|, который ведет поиск слева направо, и \lstinline|rfind()|, который ищет справа налево. На вход методы принимают подстроку типа \lstinline|std::string| и возвращают индекс начальной позиции этой подстроки. Если данной подстроки нет, то возвращается \lstinline|std::string::npos|.

Примеры:
\begin{lstlisting}
std::string str("abcdefghiabc");

std::cout << str.find("abc") << std::endl; // 0
std::cout << str.find("fg") << std::endl; // 5
std::cout << str.rfind("abc") << std::endl; // 9
std::cout << str.rfind("zzz") << std::endl; // string::npos
\end{lstlisting}

Методы \lstinline|find_first_of(), find_last_of(), find_first_not_of(), find_last_not_of()| принимает на вход набор символов в виде \lstinline|std::string| и возвращают индекс первого\textbackslash последнего вхождения\textbackslash отсутствия в зависимости от своей функции, в противном случае методы возвращают \lstinline|std::string::npos|.

Назначения методов:
\begin{itemize}
    \item \lstinline|find_first_of|~---~возвращает индекс первого вхождения любого из символов параметра в строке;
    \item \lstinline|find_last_of|~---~возвращает индекс последнего вхождения любого из символов параметра в строке;
    \item \lstinline|find_first_not_of|~---~возвращает индекс первого вхождения любого символа \textbf{не} из символов параметра в строке;
    \item \lstinline|find_last_not_of|~---~возвращает индекс последнего вхождения любого символа \textbf{не} из символов параметра в строке.
\end{itemize}

Примеры:
\begin{lstlisting}
std::string str("abcdefghiabc");

std::cout << str.find_first_of("tree") << std::endl; // 4
std::cout << str.find_last_of("cat") << std::endl; // 11
std::cout << str.find_first_not_of("father") << std::endl; // 1
std::cout << str.find_last_not_of("car") << std::endl; // 10
\end{lstlisting}

\subsubsection{Удаление символов из строки (\texttt{erase(), clear()})}

При помощи метода \lstinline|erase()| можно удалить $n$--ое количество символов:

\lstinline|erase(index, length)|

\lstinline|index| указывает индекс с которого необходимо начать удаление, \lstinline|length| указывает сколько символов необходимо удалить. Если не указывать параметр \lstinline|length|, то будут удаление будет происходить до конца строки.

Примеры:
\begin{lstlisting}
std::string test("abcdefgh");
test.erase(3);
std::cout << test << std::endl; // test = "abc"

test = "12345678";
test.erase(1, 6);
std::cout << test << std::endl; // test = "18";
\end{lstlisting}

Если необходимо полностью очистить строку, то необходимо использовать метод \lstinline|clear()|:
\begin{lstlisting}
std::string test("1234abcd");
std::cout << test.empty() << std::endl; // 0

test.clear();
std::cout << test.empty() << std::endl; // 1
\end{lstlisting}

\subsubsection{Замена символов в строке (\texttt{replace()})}

Для замены символов в строке необходимо использовать метод \lstinline|replace()|:

\lstinline|replace(index, length, replaceString)|

\lstinline|index| указывает с какого индекса в строке необходимо произвести замену, \lstinline|length| указывает сколько символов необходимо заменить, \lstinline|replaceString| является строкой, на которую происходит замена.

Пример:
\begin{lstlisting}
std::string test("1234abcd");
test.replace(4, 4, "5678");
std::cout << test << std::endl;
// test = "12345678"
\end{lstlisting}

\subsubsection{Вставка символов в строку(\texttt{insert()})}
Для вставки символов в строку необходимо использовать метод \lstinline|insert()|:

\lstinline|insert(index, insertString)|

\lstinline|index| указывает индекс, с которого необходимо сделать вставку, \lstinline|insertString| является строкой, которую необходимо вставить.

Пример:
\begin{lstlisting}
std::string test("14");
test.insert(1, "23");
std::cout << test << std::endl; // "1234"
\end{lstlisting}