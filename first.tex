\section{Введение в С++}

\subsection{Переменные (объявление, операции с переменными)}

Синтаксис объявления переменных:
\lstset{style=CPlusPlus}
\begin{lstlisting}
    <Modification> <Type> variableName = variableValue; 
\end{lstlisting}

\textit{Type} --- тип переменной, \textit{Modification} --- изменение (модификация), накладываемое на переменную, \textit{variableName} --- имя переменной, \textit{variableValue} --- значение переменной. После объявления переменной имеет смысл назначить ей какое-либо допустимое значение. Даже если переменная будет изменяться в дальнейшем коде программы, правилом хорошего тона является выставления значения по умолчанию, в противном случае при выполнении программы в этих переменных может оказаться <<мусор>> (случайные значения).

Стандартные типы:
\begin{enumerate}
    \item \textit{bool} --- логический тип, принимает значения \textbf{true} (истина), либо \textbf{false} (ложь) (1 байт);
    \item \textit{char} --- целочисленный тип, принимает значения в диапазоне $\left[ -128 \ldots 127 \right]$ (1 байт). Используется для представления символов ('a', 'z', '.', \ldots);
    \item \textit{int} --- целочисленный тип, принимает значения в диапазоне \\ $\left[ -2147483648 \ldots 2147483647 \right]$ (4 байта). Используется для хранения \textbf{целых} чисел;
    \item \textit{float} --- вещественный тип, принимает значения в диапазоне $3.4E \pm 38$ (7~знаков, 4 байта). Используется для хранения \textbf{дробных} чисел;
    \item \textit{double} --- вещественный тип, принимает значения в диапазоне $1.7E \pm 308$ (15 знаков, 8 байт). Используется для хранения \textbf{дробных} чисел, обладает большей точностью, чем тип \textit{float}.  
\end{enumerate} 

Возможные модификаторы:
\begin{enumerate}
    \item \textit{const} --- запрет менять значение переменной в ходе программы. Если попытаться поменять где-нибудь константу, то компилятор сообщит о ошибке:
    \lstset{style=CPlusPlus}
    \begin{lstlisting}
        const double pi = 3.1415;
        pi = 3.0; // This is wrong!!!
    \end{lstlisting}
    \item \textit{unsigned} --- переменная будет принимать только положительные значения. Например, \textit{unsigned char} будет принимать значения $\left[ 0 \ldots 255 \right]$;
    \item \textit{short} --- укорачивает диапазон переменных. Например, \textit{short int} будет принимать значения $\left[ -32768 \ldots 32767 \right]$;
    \item \textit{long} --- увеличивает диапазон переменных.
\end{enumerate}

Подробнее про размерности переменных можно почитать \href{https://msdn.microsoft.com/ru-ru/library/s3f49ktz%28v=vs.120%29.aspx}{по данному адресу}.

На одной строке можно объявлять несколько переменных одного типа:
\lstset{style=CPlusPlus}
\begin{lstlisting}
    int p = 2,k = 3;
    double s,m; // bad thing, because there is no initialization!
\end{lstlisting}

Стандартные арифметические операции над переменными:
\begin{enumerate}
    \item Операция присваивания ($=$). Значение выражения присваивается переменной:
    \lstset{style=CPlusPlus}
    \begin{lstlisting}
       int a = 5;
       int b = 42; // a = 5, b = 42
       a = b; // a = 42, b = 42
    \end{lstlisting}
    \item Операция сложения ($+$), вычитания ($-$), умножения ($*$), целочисленное деление ($/$), взятие остатка по модулю ($\%$):
    \lstset{style=CPlusPlus}
    \begin{lstlisting}
        int a = 5;
        int b = 3;
        
        int l = 5 + 3 - 1; // l = 7
        int c = a + b; // c = 8
        int d = a - b; // d = 2
        int k = a * b; // k = 15
        int div = a / b; // div = 1
        int mod = a % b; // mod = 2
    \end{lstlisting}
    
    Первоначально обрабатываются операции умножения, деления и взятия остатка по модулю. Если операций несколько, то выполняются слева направо. После этих операций по такому же принципу обрабатываются и операции сложения и вычитания.
    
    \item Операция (). Выражения в скобках оцениваются в первую очередь. В случае вложенных скобок вычисляется значение во внутренних скобках. Если есть одинаковые скобки <<одного уровня>> --- они вычисляются слева направо. 
\end{enumerate} 

Существуют короткие формы записей арифметических операций:
\lstset{style=CPlusPlus}
\begin{lstlisting}
    a += b --> a = a + b
    a -= b --> a = a - b
    a *= b --> a = a * b
    a /= b --> a = a / b
    a %= b --> a = a % b
\end{lstlisting}

В С++ существуют операции инкремента ($++$) и декремента ($--$). Данные операции увеличивают или уменьшают значение переменной на 1. Различают префиксную форму ($++$а / $--$b) и суффиксную (постфиксную) форму (a$++$ / b$--$). Различие между формами в том, что при использовании префиксной формы значение переменной изменяется сразу же, как программа выполняет данную операцию; в суффиксной --- программа сперва использует старое значение, а потом изменяет его.

Операции сравнения над переменными:
\begin{enumerate}
    \item Операция равенства ($==$). Принимает значение \textbf{true}, если оба выражения равны, в противном случае --- \textbf{false}. \textit{Не следует путать с присваиванием значения переменной!!!}
    
    \lstset{style=CPlusPlus}
    \begin{lstlisting}
        bool result = 4 % 2 == 0; // true
        
        int a = 5;
        int b = 2;
        bool newResult = a == b; // false 
    \end{lstlisting}    
    
    \item Операция неравенства (!=). Принимает значение \textbf{true}, если оба выражения различны, в противном случае --- \textbf{false};
    \item Операции отношения (>, <, >=, <=). Возвращают значение типа \textit{bool} в зависимости от своей функции:
    
    \lstset{style=CPlusPlus}
    \begin{lstlisting}
        bool a = 5 > 3; // true
        bool b = 4 < 2; // false
        bool c = 6 <= 6; // true
        bool d = 5 >= 2; // true
    \end{lstlisting}
\end{enumerate}

Все операции выполняются слева направо, кроме операции $=$ --- она выполняется справа налево! Также не стоит забывать при работе с числовыми переменными про границы типов, иначе может возникнуть переполнение!

\newpage

Логические операции:

\begin{enumerate}
    \item Логическое отрицание (!) --- Инвертирует логическое значение.
    \item Логическое умножение, И (\&\&). Если первое выражение равно \textit{false}, то тогда вычисление второго выражения не производится.
    \item Логическое сложение, ИЛИ ($\parallel$). Вычисляются оба выражения.
\end{enumerate}

