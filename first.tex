\section{Введение в С++}

\subsection{Переменные (объявление, типы, операции с переменными)}

\subsubsection{Объявление переменных}
Синтаксис объявления переменных:
\lstset{style=CPlusPlus}
\begin{lstlisting}
    <Modification> <Type> variableName = variableValue;
\end{lstlisting}

\textit{Type} --- тип переменной, \textit{Modification} --- изменение (модификация), накладываемое на переменную, \textit{variableName} --- имя переменной, \textit{variableValue} --- значение переменной.

После объявления переменной имеет смысл назначить ей какое-либо допустимое значение. Даже если переменная будет изменяться в дальнейшем коде программы, правилом хорошего тона является выставления значения по умолчанию, в противном случае при выполнении программы в этих переменных может оказаться <<мусор>> (случайные значения).

Инициализацию переменной можно двумя способами:
\begin{itemize}
    \item Через оператор $=$:
    \begin{lstlisting}
       int a = 5;
    \end{lstlisting}
    \item Через оператор $()$ --- инициализация переменной с помощью конструктора:
    \lstset{style=CPlusPlus}
    \begin{lstlisting}
       int a(5);
    \end{lstlisting}
\end{itemize}

\subsubsection{Типы переменных}
Стандартные типы:
\begin{enumerate}
    \item \textit{bool} --- логический тип;
    \item \textit{char} --- целочисленный тип, используется для представления символов ('a', 'z', '.', \ldots);
    \item \textit{int} --- целочисленный тип, используется для хранения \textbf{целых} чисел;
    \item \textit{float} --- вещественный тип, используется для хранения \textbf{дробных} чисел;
    \item \textit{double} --- вещественный тип, используется для хранения \textbf{дробных} чисел, обладает большей точностью, чем тип \textit{float}.
\end{enumerate}

Возможные модификаторы:
\begin{enumerate}
    \item \textit{const} --- запрет менять значение переменной в ходе программы. Если попытаться поменять где-нибудь константу, то компилятор сообщит о ошибке:
    \begin{lstlisting}
        const double pi = 3.1415;
        pi = 3.0; // This is wrong!!!
    \end{lstlisting}
    \item \textit{unsigned} --- переменная будет принимать только положительные значения;
    \item \textit{short} --- укорачивает диапазон переменных;
    \item \textit{long} --- увеличивает диапазон переменных.
\end{enumerate}

Размерности переменных:
\begin{table}[h]
    \centering
    \begin{tabular}{|>{\centering\arraybackslash}m{4cm}|>{\centering\arraybackslash}m{2cm}|>{\centering\arraybackslash}m{10cm}|}
        \hline
        \textit{Тип} & \textit{Размер в байтах} & \textit{Диапазон} \\
        \hline
        byte & 1 & true/false \\
        \hline
        char & 1 & \numrange{-128}{127} \\
        \hline
        unsigned char & 1 & \numrange{0}{255} \\
        \hline
        short int & 2 & \numrange{-32 768}{32 767} \\
        \hline
        unsigned short int & 2 & \numrange{0}{65 535} \\
        \hline
        int & 4 & \numrange{-2 147 483 648}{2 147 483 647} \\
        \hline
        unsigned int & 4 & \numrange{0}{4 294 967 295} \\
        \hline
        long int & 4 & \numrange{-2 147 483 648}{2 147 483 647} \\
        \hline
        unsigned long int & 4 & \numrange{0}{4 294 967 295} \\
        \hline
        long long & 8 & \num{-9 223 372 036 854 775 808} \ldots \newline \ldots \num{9 223 372 036 854 775 807} \\
        \hline
        unsigned long long & 8 & \numrange{0}{18 446 744 073 709 551 615} \\
        \hline
        float & 4 & $\pm 3.4\cdot 10^{\pm 38}$ (7 цифр) \\
        \hline
        double & 8 & $\pm 1.7\cdot 10^{\pm 308}$ (15 цифр) \\
        \hline
    \end{tabular}
\end{table}

На одной строке можно объявлять несколько переменных одного типа:
\begin{lstlisting}
    int p = 2,k = 3;
    double s,m; // bad thing, because there is no initialization!
\end{lstlisting}

\subsubsection{Операции с переменными}
Стандартные арифметические операции над переменными:
\begin{enumerate}
    \item Операция присваивания ($=$). Значение выражения присваивается переменной:
    \begin{lstlisting}
       int a = 5;
       int b = 42; // a = 5, b = 42
       a = b; // a = 42, b = 42
    \end{lstlisting}
    \item Операция сложения ($+$), вычитания ($-$), умножения ($*$), целочисленное деление ($/$), взятие остатка по модулю ($\%$):
    \begin{lstlisting}
        int a = 5;
        int b = 3;

        int l = 5 + 3 - 1; // l = 7
        int c = a + b; // c = 8
        int d = a - b; // d = 2
        int k = a * b; // k = 15
        int div = a / b; // div = 1
        int mod = a % b; // mod = 2
    \end{lstlisting}

    Первоначально обрабатываются операции умножения, деления и взятия остатка по модулю. Если операций несколько, то выполняются слева направо. После этих операций по такому же принципу обрабатываются и операции сложения и вычитания.

    \item Операция (). Выражения в скобках оцениваются в первую очередь. В случае вложенных скобок вычисляется значение во внутренних скобках. Если есть одинаковые скобки <<одного уровня>> --- они вычисляются слева направо.
\end{enumerate}

Существуют короткие формы записей арифметических операций:
\begin{lstlisting}
    a += b --> a = a + b
    a -= b --> a = a - b
    a *= b --> a = a * b
    a /= b --> a = a / b
    a %= b --> a = a % b
\end{lstlisting}

В С++ существуют операции инкремента ($++$) и декремента ($--$). Данные операции увеличивают или уменьшают значение переменной на 1. Различают префиксную форму ($++$а / $--$b) и суффиксную (постфиксную) форму (a$++$ / b$--$). Различие между формами в том, что при использовании префиксной формы значение переменной изменяется сразу же, как программа выполняет данную операцию; в суффиксной --- программа сперва использует старое значение, а потом изменяет его.

Операции сравнения над переменными:
\begin{enumerate}
    \item Операция равенства ($==$). Принимает значение \textbf{true}, если оба выражения равны, в противном случае --- \textbf{false}. \textit{Не следует путать с присваиванием значения переменной!!!}

    \begin{lstlisting}
        bool result = 4 % 2 == 0; // true

        int a = 5;
        int b = 2;
        bool newResult = a == b; // false
    \end{lstlisting}

    \item Операция неравенства (!=). Принимает значение \textbf{true}, если оба выражения различны, в противном случае --- \textbf{false};
    \item Операции отношения (>, <, >=, <=). Возвращают значение типа \textit{bool} в зависимости от своей функции:

    \begin{lstlisting}
        bool a = 5 > 3; // true
        bool b = 4 < 2; // false
        bool c = 6 <= 6; // true
        bool d = 5 >= 2; // true
    \end{lstlisting}
\end{enumerate}

Все операции выполняются слева направо, кроме операции $=$ --- она выполняется справа налево! Также не стоит забывать при работе с числовыми переменными про границы типов, иначе может возникнуть переполнение!

Логические операции:

\begin{enumerate}
    \item Логическое отрицание (!) --- Инвертирует логическое значение;
    \item Логическое умножение, И (\&\&). Если первое выражение равно \textit{false}, то тогда вычисление второго выражения не производится;
    \item Логическое сложение, ИЛИ ($\parallel$). Первое выражение вычисляется всегда, второе вычисляется в том случае, если первое выражение принимает значение \textit{fasle}.
\end{enumerate}

\subsection{Условный оператор \textit{if}, тернарный оператор, оператор \textit{switch}}
\subsubsection{Условный оператор \textit{if}}
Общая структура условного оператора:
\begin{lstlisting}
    if (expression_1)
    {
        statement_1
    }
    [else
        statement_2]
\end{lstlisting}

\textit{expression} --- логическое выражение; \textit{statement\_X} --- набор операций.

Начало условия задается ключевым словом \textit{if}, после которого в круглых скобках идет логическое выражение типа \textit{bool}. Наличие круглых скобок вне выражения обязательно, в противном случае компилятор выкинет ошибку. После выражения идут операции, которые следует выполнять в том случае, если выражение в круглых скобках истинно. Если операций несколько, то необходимо поставить фигурные скобки, в противном случае ими можно обойтись.

Пример условия:

\begin{lstlisting}
    int a = 13;
    if (a < 16)
        a = a + 2;

    // a = 15

    int count = 2;
    if (count > 3)
    {
        count++;
        age += 5;
    }

    // count = 2, age = 15
\end{lstlisting}

Если необходимо выполнить набор действий в том случае, когда выражение ложно, то необходимо поставить ключевое слово \textit{else} и перечислить набор операций (если операция одна, то фигурные скобки можно опустить, в противном случае они обязательны). Если условие не предполагает действий в том случае, если выражение в скобках ложно, то нет необходимости ставить \textit{else}.

Пример:
\begin{lstlisting}
    int a = 5;
    int b = 0;

    if (a % 2 == 0)
        b++;
    else
    {
        a--;
        b--;
    }

    // b = -1
\end{lstlisting}

Допускается использования нескольких блоков if \ldots else:

\begin{lstlisting}
    int age = 15;

    if (age <= 3)
        ...
    else if (age > 3 && age <= 7)
        ...
    else if (age > 7 && age <= 18)
        ...
    else
        ...
\end{lstlisting}

\subsubsection{Тернарный оператор}
Структура тернарного оператора:

\begin{lstlisting}
    expression ? statement_1 : statement_2;
\end{lstlisting}

В данном операторе сперва вычисляется выражение \textit{expression}. Если данное выражение принимает значение \textit{true}, то идет выполнение того, что написано в \textit{statement\_1}, в противном случае выполняется \textit{statement\_2}.

Пример:
\begin{lstlisting}
    int a = 3, b = 5;
    int min = a < b ? a : b;
    // a = 3
\end{lstlisting}

\subsubsection{Оператор \textit{switch}}
Структура оператора \textit{switch}:
\begin{lstlisting}
    switch ( expression )
        case constant-expression : statement
        [default   : statement]
\end{lstlisting}

\textit{expression} --- выражение, которое можно привести к целочисленному типу; \textit{constant-expression} --- константное значение, если выражение будет иметь данное значение, то произойдет обработка блока \textit{statement}. Если ни один из \textit{case}'ов не сработал, то вычисляется \textit{statement} в блоке \textit{default}, однако данный блок не обязателен к указанию и может быть опущен --- в таком случаю программа перейдет к выполнению следующих инструкций после оператора \textit{switch}.

Пример использования:
\begin{lstlisting}
    int month = 4;
    switch (month)
    {
        case 1:
            ...
            break;
        case 2:
            ...
            break;
        ...
        case 4:
            ...
            break;
        ...
        case 12:
            ...
            break;
        default:
            ...
    }
\end{lstlisting}

В данном примере будут выполняться инструкции, которые идут в блоке \textit{case~4}. Обратите внимание, что после окончания инструкций в блоке стоит оператор \textit{break}~---~он необходим для прекращения работы оператора \textit{switch} после выполнения команд в блоке, в противном случае оператор \textit{switch} будет продолжать свою работу!

Существует возможность указания нескольких \textit{case}'ов для одного и того же блока команд:

\begin{lstlisting}
    char answer = 'y';
    switch (answer)
    {
        case 'y':
        case 'Y':
            ...
            break;
        case 'n':
        case 'N':
            ...
            break;
    }
\end{lstlisting}
 
\subsection{Циклы \textit{while}, \textit{do-while}, \textit{for}}
\subsubsection{Цикл \textit{while}}
Структура цикла \textit{while}:
\begin{lstlisting}
    while (expression)
    {
        statement
    }
\end{lstlisting}
 
\textit{Expression} --- выражение типа \textit{bool}, задает условие выхода из цикла; \textit{statement}~---~набор операций, которые будут выполняться в цикле (если операций больше одной, то нужно заключить их в фигурные скобки, в противном случае делать данное действие необязательно). Цикл \textit{while} будет выполняться до тех пор, пока \textit{expression} будет равно \textit{true}. Программа может не войти в тело цикла (то есть выполнить операции в нем), если изначально \textit{expression} будет равен \textit{false}.

Пример:

\begin{lstlisting}
    int a = 0;
    int b = 0;
    while (a < 10)
    {
        b *= a*a;
        a++;
    }
\end{lstlisting}

Цикл \textit{while} можно досрочно завершить при помощи оператора $break$ (управление программы перейдет к следующей инструкции):

\begin{lstlisting}
    
    char answer = 'v';
    
    while (a != 'y')
    {
        ...
        
        if (answer == 'q')
            break;
            
        ...
    }
    
\end{lstlisting}

В данном примере выход из цикла произойдет в двух случаях: пока переменная \textit{answer} не примет значение \textit{y}, либо значение \textit{q}. Во втором случае все операции после данного условия не будут выполнены и произойдет выход из цикла.

Если использовать оператор \textit{continue} в цикле, то все операции выполняться также не будут, однако цикл не будет завершен и его выполнение будет продолжено с самой первой операции в цикле. 

\subsubsection{Цикл \textit{do-while}}
Структура цикла \textit{do-while}:
\begin{lstlisting}
    do
    {
        statement
    } while (expression);
\end{lstlisting}

\textit{Expression} --- выражение типа \textit{bool}, задает условие выхода из цикла; \textit{statement}~---~набор операций, которые будут выполняться в цикле (если операций больше одной, то нужно заключить их в фигурные скобки, в противном случае делать данное действие необязательно). Цикл \textit{do-while} будет выполняться до тех пор, пока выражение \textit{expression} будет равно \textit{true}. В данном цикле блок \textit{statement} будет выполняться в первую очередь, условие выхода из цикла будет проверяться после выполнения операций. Операторы \textit{break} и \textit{continue} имеют такой же эффект, что и в цикле \textit{while}.

Пример:
\begin{lstlisting}
    int a = 0;
    do
    {
        a++;
    } while (a < 10);
\end{lstlisting}

\subsubsection{Цикл \textit{for}}
Конструкция цикла \textit{for}:
\begin{lstlisting}
    for (init-expression ; cond-expression ; loop-expression)
    {
        statement;
    }
\end{lstlisting}

Обозначения:
\begin{itemize}
    \item \textit{init-expression} --- набор операций, которые выполняются один раз \textbf{до} начала цикла, чаще всего используется для инициализации переменных, которые будут использоваться в цикле для подсчета итераций;
    \item \textit{cond-expression} --- выражение типа \textit{bool}, которое задает условие выхода из цикла --- проверяется перед каждой итерацией цикла (в том числе и перед самой первой), если \textit{cond-expression} равное \textit{false}, то цикл завершается;
    \item \textit{loop-expression} --- набор операций, который выполняется после итерации цикла, обычно используется для изменения переменных, который подсчитывают количество итераций;
    \item \textit{statement} --- набор операций, которые будут производится в каждой итерации цикла (если операций больше одной, то нужно заключить их в фигурные скобки, в противном случае делать данное действие необязательно).
\end{itemize}
  
Пример:

\begin{lstlisting}
    int sum = 0;
    const int lim = 10;
    
    for (int i = 0; i < lim; ++i)
        sum += i;
\end{lstlisting}

В блоках \textit{init-expression} и \textit{loop-expression} может быть несколько выражений, разделенных запятой:
\begin{lstlisting}
    int sum = 0;

    for (int i = 0, int j = 0; i + j < lim; ++i, ++j)
        sum += i + j;
\end{lstlisting}

В блоке \textit{loop-expression} переменные, ответственные за количество итераций, могут изменяться по разному:
\begin{lstlisting}
    for (int i = 10; i > 0; --i)
    {
        ...
    }
    
    for (int k = 0; k > 200; k += 2)
    {
        ...
    }
\end{lstlisting}

Операторы \textit{break} и \textit{continue} имеют такой же эффект, что и в циклах \textit{while} и \textit{do-while}.

\subsection{Массивы}
\subsubsection{Одномерные массивы}
Общая структура:
\begin{lstlisting}
    Type arrayName[arraySize];
\end{lstlisting}

\textit{Type} --- тип массива (массив может состоять из целых чисел, дробных, символов, \ldots); \textit{arrayName}~---~название массива; \textit{arraySize}~---~размер массива. Индексы, по которым можно обращаться к элементам массива, лежат в диапазоне $\left[ 0 \ldots \text{arraySize} - 1 \right]$. Обращение к элементу одномерного массива по индексу --- arrayName[\textit{index}].

Инициализация одномерного массива:
\begin{itemize}
    \item Использовать инициализатор \{\} при объявлении массива:
    \begin{lstlisting}
        int costs[4] = {100, 200, 300, 400};
    \end{lstlisting}
    
    В таком случае можно не указывать размер массива:
    \begin{lstlisting}
        int costs[] = {2, 4, 6};
    \end{lstlisting}
    
    \item Инициализировать массив при помощи циклов:
    \begin{lstlisting}
        const int arraySize = 5;
        int myArray[arraySize];
        
        for (int i = 0; i < arraySize; ++i)
            myArray[i] = ...;
    \end{lstlisting}
\end{itemize}

Пример инициализированного массива:

\begin{tabular}{|c|c|c|c|c|}
  \hline
  Индекс массива & 0 & 1 & 2 & 3 \\
  \hline
  Значение массива & 34 & -4 & 11 & 64 \\
  \hline
\end{tabular}

Рекомендуется при работе с одномерными массивами инициализировать их, т.к. в противном случае в элементах массивов будет записан <<мусор>>!

\subsubsection{Двумерные массивы}
Общая структура:
\begin{lstlisting}
    Type arrayName[arraySizeRow][arraySizeColumn];
\end{lstlisting}

\textit{Type} --- тип массива (массив может состоять из целых чисел, дробных, символов, \ldots); \textit{arrayName}~---~название массива; \textit{arraySizeRow}~---~количество одномерных массивов, \textit{arraySizeColumn}~---~размер каждого одномерного массива. Количество одномерных массивов лежит в диапазоне $\left[ 0 \ldots \text{arraySizeRow} - 1 \right]$, размерность одномерных массивов~---~$\left[ 0 \ldots \text{arraySizeColumn} - 1 \right]$. Обращение к элементу двумерного массива по индексам --- arrayName[\textit{indexRow}][\textit{indexColumn}].

Инициализация двумерного массива:
\begin{itemize}
    \item Использовать инициализатор \{\} при объявлении массива:
    \begin{lstlisting}
        int example[][5] = 
        {
            {100, 200, 300, 400},
            {200, 600, 1000, 1400},
            {1000, 800, 600, 400}
        }
    \end{lstlisting}
    
    Обратите внимание, что указывается размерность одномерных массивов, но не количество этих массивов!
    
    \item Инициализировать массив при помощи циклов:
    \begin{lstlisting}
        const int rowSize = 3;
        const int columnSize = 5;
        int myArray[rowSize][columnSize];

        for (int i = 0; i < rowSize; ++i)
            for (int j = 0; j < columnSize; ++j)
                myArray[i][j] = ...;    
    \end{lstlisting}
\end{itemize}

Пример инициализированного массива:

\begin{tabular}{|c|c|c|c|c|}
    \hline
      & 0 & 1 & 2 & 3 \\
    \hline
    0 & 24 & 25 & 23 & 22 \\
    \hline
    1 & 1 & 2 & 3 & 4 \\
    \hline
    2 & 3 & 5 & 7 & 11 \\
    \hline
    3 & 10 & 15 & 20 & 25 \\
    \hline
    4 & 11 & 22 & 33 & 44 \\
    \hline
    5 & 0 & 2 & 4 & 6 \\
    \hline
\end{tabular}